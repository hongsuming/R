# Matrices : 2차원의 dataset 이다. 이는 매트릭스 함수에 벡터를 제공함으로써 만들 수 있다.
# 동일 데이터 타입을 갖는 2차원 배열(행렬 구조).
# 선형대수학 정리 http://kipid.tistory.com/entry/Linear-Algebra
# - 생성 함수 : dim(), matrix(), rbind(), cbind()
# : matrix: 긴 벡터를 잘라서 행렬로 변환
# : cbind: 여러 개의 벡터를 좌우로 붙여서 행렬로 변환
# : rbind: 여러 개의 벡터를 위아래로 붙여서 행렬로 변환
# - 처리함수 : apply()

a <- 1:8
dim(a) # NULL
a # 1 2 3 4 5 6 7 8
dim(a) <- c(2, 4) # 벡터 값을 2행 4열의 매트릭스로 만듦
a #      [,1] [,2] [,3] [,4]
  #      [1,]    1    3    5    7
  #      [2,]    2    4    6    8
typeof(a) # "integer"
class(a) # "matrix" "array" 

m <- matrix(1:5)
m #             [,1]
#        [1,]    1
#        [2,]    2
#        [3,]    3
#        [4,]    4
#        [5,]    5
dim(m) # 5 1 (5행 1열)
m <- matrix(1:9, nrow=3) # 열부터 채움
m #      [,1] [,2] [,3]
  # [1,]    1    4    7
  # [2,]    2    5    8
  # [3,]    3    6    9
dim(m) # 3 3
m <- matrix(1:9, nrow=3, byrow=T) # 행부터 채움움
m #      [,1] [,2] [,3]
  # [1,]    1    2    3
  # [2,]    4    5    6
  # [3,]    7    8    9
dim(m) # 3 3
m <- matrix(1:10, 2)
m #      [,1] [,2] [,3] [,4] [,5]
  # [1,]    1    3    5    7    9
  # [2,]    2    4    6    8   10
dim(m) # 2 5
m <- matrix(1:10, 3)
m #      [,1] [,2] [,3] [,4]
  # [1,]    1    4    7   10
  # [2,]    2    5    8    1
  # [3,]    3    6    9    2
dim(m) # 3 4

m[1,] # 1  4  7 10 (슬라이싱 1행)
m[, 3] # 7 8 9 (슬라이싱 3열)
m[2, 3] # 8 (슬라이싱 2행 3열)
m[1, c(2:4)] # 4  7 10
m[, -1] #      [,1] [,2] [,3] (1열을 제외한 나머지 여집합)
        # [1,]    4    7   10
        # [2,]    5    8    1
        # [3,]    6    9    2
m[-1, -1] #      [,1] [,2] [,3] (1행, 1열을 제외한 나머지 여집합)
          # [1,]    5    8    1
          # [2,]    6    9    2

m
rownames(m) <- c('r1', 'r2', 'r3')
colnames(m) <- c('c1', 'c2', 'c3', 'c4')
m #    c1 c2 c3 c4
  # r1  1  4  7 10
  # r2  2  5  8  1
  # r3  3  6  9  2
length(m) # 12
NROW(m) # 3


# matrix 계산
a <- matrix(c(1, 2, 3, 4), 2, 2)
a #      [,1] [,2]
  # [1,]    1    3
  # [2,]    2    4
b <- matrix(5:8, 2, 2)
b #      [,1] [,2]
  # [1,]    5    7
  # [2,]    6    8

a+b #      [,1] [,2]
    # [1,]    6   10
    # [2,]    8   12
a-b #      [,1] [,2]
    # [1,]   -4   -4
    # [2,]   -4   -4
a*b #      [,1] [,2]
    # [1,]    5   21
    # [2,]   12   32
a/b #           [,1]      [,2]
    # [1,] 0.2000000 0.4285714
    # [2,] 0.3333333 0.5000000

a%*%b #      [,1] [,2] (행렬곱)
      # [1,]   23   31
      # [2,]   34   46

diag(3) #      [,1] [,2] [,3]
        # [1,]    1    0    0
        # [2,]    0    1    0
        # [3,]    0    0    1
a #      [,1] [,2]
  # [1,]    1    3
  # [2,]    2    4
t(a) #      [,1] [,2] 행렬 전환 : 전치
    # [1,]    1    2
    # [2,]    3    4
solve(a) #      [,1] [,2]
        # [1,]   -2  1.5
        # [2,]    1 -0.5
solve(solve(a)) #      [,1] [,2]
                # [1,]    1    3
                # [2,]    2    4

# 행 또는 열 결합
x1 <- c(5, 40, 50:52)
x1 # 5 40 50 51 52
x2 <- c(30, 5, 6:8)
x2 # 30  5  6  7  8
aa <- rbind(x1, x2) #    [,1] [,2] [,3] [,4] [,5] 행 묶음
                    # x1    5   40   50   51   52
                    # x2   30    5    6    7    8
cbind(x1, x2) #      x1 x2
              # [1,]  5 30
              # [2,] 40  5
              # [3,] 50  6
              # [4,] 51  7
              # [5,] 52  8

# apply 함수 : 함수를 실행하는 함수
x <- matrix(c(1:9), nrow=3, ncol=3)
x #      [,1] [,2] [,3]
  # [1,]    1    4    7
  # [2,]    2    5    8
  # [3,]    3    6    9
apply(x, 1, max) # 7 8 9 (1 : 행 기준, 2 : 열 기준)
apply(x, 1, min) # 1 2 3
apply(x, 2, mean) # 2 5 8 (열의 기준)

func <- function(x){
  x + c(5, 10, 15)
}
apply(x, 1, func) #      [,1] [,2] [,3]
                  # [1,]    6    7    8
                  # [2,]   14   15   16
                  # [3,]   22   23   24

